# Lesson15--哈希.md

## 1. unordered系列关联式容器

在 *C++98* 中, *STL* 提供了底层为红黑树结构的一系列关联式容器,在查询时效率可达到 $log_2N$ ,即最差情况下需要比较红黑树的高度次,当树中的节点非常多时,查询效率也不理想.最好的查询是,进行很少的比较次数就能将元素找到,因此在 *C++11* 中,STL又提供了4个 `unordered` 系列的关联式容器,这四个容器与红黑树结构的关联式容器使用方式基本类似,只是其底层结构不同.

### 1.1 unordered_map

#### 1.1.1 unordered_map介绍

1. `unordered_map` 是存储 `<key, value>` 键值对的关联式容器,其允许通过 `key` 快速的索引到与其对应的 `value` .
2. 在 `unordered_map` 中,键值通常用于惟一地标识元素,而映射值是一个对象,其内容与此键关联.键和映射值的类型可能不同.
3. 在内部 `unordered_map` 没有对 `<kye, value>` 按照任何特定的顺序排序, 为了能在常数范围内找到 `key` 所对应的`value` , `unordered_map` 将相同哈希值的键值对放在相同的桶中.
4. `unordered_map` 容器通过 `key` 访问单个元素要比 `map` 快,但它通常在遍历元素子集的范围迭代方面效率较低.
5. `unordered_map`实现了直接访问操作符( `operator[]` ),它允许使用 `key` 作为参数直接访问 `value` .
6. 它的迭代器至少是前向迭代器.

#### 1.1.2 unordered_map的接口说明

1. `unordered_map` 的构造
   |    函数声明     |              功能介绍               |
   | :-------------: | :---------------------------------: |
   | `unordered_map` | 构造不同格式的 `unordered_map` 对象 |
2. `unordered_map` 的容量
   |       函数声明       |              功能介绍               |
   | :------------------: | :---------------------------------: |
   | `bool empty()const`  |    检测 `unordered_map` 是否为空    |
   | `size_t size()const` | 获取 `unordered_map` 的有效元素个数 |
3. `unordered_map` 的迭代器
   | 函数声明 |                           功能介绍                           |
   | :------: | :----------------------------------------------------------: |
   | `begin`  |           返回 `unordered_map` 第一个元素的迭代器            |
   |  `end`   |     返回 `unordered_map` 最后一个元素下一个位置的迭代器      |
   | `cbegin` |       返回 `unordered_map` 第一个元素的 `const` 迭代器       |
   |  `cend`  | 返回 `unordered_map` 最后一个元素下一个位置的 `const` 迭代器 |
4. `unordered_map` 的元素访问
   |   函数声明   |                  功能介绍                   |
   | :----------: | :-----------------------------------------: |
   | `operator[]` | 返回与 `key` 对应的 `value` ,没有一个默认值 |
   注意:该函数中实际调用哈希桶的插入操作,用参数 `key` 与 `V()` 构造一个默认值往底层哈希桶中插入,如果 `key` 不在哈希桶中,插入成功,返回 `V()` ,插入失败,说明 `key` 已经在哈希桶中,将 `key` 对应的 `value` 返回`.
5. `unordered_map` 的查询
   |           函数声明            |               功能介绍                |
   | :---------------------------: | :-----------------------------------: |
   | `iterator find(const K& key)` |      返回 `key` 在哈希桶中的位置      |
   | `size_t count(const K& key)`  | 返回哈希桶中关键码为key的键值对的个数 |
   注意: `unordered_map` 中 `key` 是不能重复的,因此 `count` 函数的返回值最大为1.
6. `unordered_map` 的修改操作
   |          函数声明           |        功能介绍        |
   | :-------------------------: | :--------------------: |
   |          `insert`           |   向容器中插入键值对   |
   |           `erase`           |   删除容器中的键值对   |
   |       `void clear()`        | 清空容器中有效元素个数 |
   | `void swap(unordered_map&)` |  交换两个容器中的元素  |
7. `unordered_map` 的桶操作
   |              函数声明               |          功能介绍           |
   | :---------------------------------: | :-------------------------: |
   |    `size_t bucket_count()const`     |   返回哈希桶中桶的总个数    |
   | `size_t bucket_size(size_t n)const` | 返回n号桶中有效元素的总个数 |
   |   `size_t bucket(const K& key) `    |    返回元素key所在的桶号    |

### 1.2 unordered_set

## 2. 底层结构

### 2.1 哈希

哈希Hash(散列),采用直接寻址方式,在理想情况下,查找的时间复杂度可以达到常数阶 $\Omicron (1)$ .

哈希通过哈希函数将要参与检索的数据与哈希值关联起来,生成一种便于搜索的数据结构,我们称其为哈希表,也就是说,我们需要将一堆数据保存起来,这些数据会通过哈希函数进行计算,得到与其对应的哈希值,当我们下次需要查找这些数据时,只需要再次计算哈希值就能快速找到对应的元素.

### 2.2 哈希冲突

对于两个数据元素的关键字 $k_i , k_j (i \neq j)$ ,但有 $Hash(k_i)=Hash(k_j)$ ,即:不同关键字通过相同哈希函数计算出相同哈希地址,该现象称为 **哈希冲突** 或 **哈希碰撞** .

具有不同关键码而具有相同哈希地址的数据元素称为 **同义词** .

### 2.3 哈希函数

引起哈希冲突的一个原因可能是哈希函数设计不合理.

**哈希函数设计原则:**
* 哈希函数的定义域必须包括需要存储的全部关键码,而如果散列表允许有m个地址时,其值域必须在0到m-1之间.
* 哈希函数计算出来的地址能均匀分布在整个空间中.
* 哈希函数应该比较简单.

**常见哈希函数:**
1. 直接定址法
   取关键字的某个线性函数为散列地址: $Hash(Key)=A*Key+B$
   优点:简单,均匀
   缺点:需要事先知道关键字的分布情况
   使用场景:适合查找比较小且连续的情况
2. 除留余数法
   设散列表中允许的地址数为m,取一个不大于m,但最接近或者等于m的质数p作为除数,按照哈希函数: $Hash(key)=key \% p (p \le m)$ ,将关键码转换成哈希地址
3. 平方取中法
4. 折叠法
5. 随机数法
6. 数学分析法

### 2.4 哈希冲突解决

#### 2.4.1 闭散列

闭散列:也叫开放定址法,当发生哈希冲突时,如果哈希表未被装满,说明在哈希表中必然还有空位置,那么可以把 `key` 存放到冲突位置中的 "下一个" 空位置中去.

##### 2.4.1.1 线性探测

从发生冲突的为止开始,依次向后探测,直到寻找到下一个空位置为止.
* 插入:
  * 通过哈希函数获取待插入元素在哈希表中的位置.
  * 如果该位置没有元素则直接插入新元素,如果该位置中由元素发生哈希冲突,使用线性探测找到下一个空位置,插入元素.
* 删除:
  * 采用闭散列处理哈希冲突时,不能随便物理删除哈希表中已有的元素,若直接删除元素会影响其它元素的搜索.因此,线性探测采用标记的伪删除法来删除一个元素.
  线性探测优点:实现非常简单.
  线性探测缺点:一旦发生哈希冲突,容易产生数据"堆积",使得寻找某关键码的位置需要多次比较,导致搜索效率降低.

##### 2.4.1.2 二次探测
   
线性探测的缺陷时产生冲突的数据堆在一块,这与其找下一个空位置有关系,二次探测为了避免该问题,找下一个空位置的方法为: $H_i = (H_0+i^2)\pmod m$ 或者 $H_i = (H_0- i^2)\pmod m$ ,其中: $i=1,2,3...$ , $H_0$ 是通过散列函数 $Hash(x)$ 对元素的关键码 `key` 进行计算得到的位置, $m$ 是表的大小.

研究表明:当表的长度为质数且装载因子a不超过0.5时,新的表项一定能够插入,而且任何一个位置都不会被探查两次.因此只要表中有一半的空位置,就不会存在表满的问题.在搜索时可以不考虑表装满的情况,但在插入时必须确保表的装载因子a不能超过0..5,如果超出,必须考虑扩容.

闭散列最大的缺陷就是空间利用率比较低,这也是哈希的缺陷.

#### 2.4.2 开散列

##### 2.4.2.1 开散列概念